# Haiway Framework

Haiway is a functional/async framework built around immutable `State`, context-scoped dependency injection (`ctx`), and structured concurrency. Keep typing strict and behavior explicit.

## Core Ideas
- Immutable data: every domain/config object subclasses `State`; instances cannot be mutated, updates are done via `.updating(...)`.
- Context-first DI: `async with ctx.scope(name_or_preset, *state, disposables=(...)):` installs state for the lifetime of the scope. `ctx.state(Type)` resolves by type. Priority: explicit state > disposables > preset state > parent scope.
- Protocol-driven logic: define contracts as `Protocol` and inject implementations as state. Expose public API via `@statemethod` on service `State` containers.
- Structured concurrency: tasks live inside the current scope task group via `ctx.spawn`. Logging, cancellation, and state all propagate automatically.
- Observability: never `print`. Use `ctx.log_*` and `ctx.record_*`; tracing hooks live in `haiway.context.observability` and can be bridged with OpenTelemetry via `LoggerObservability` or `opentelemetry` adapters.

## Minimal Skeleton
```python
from haiway import State, ctx, statemethod
from typing import Protocol, runtime_checkable
from uuid import UUID

class User(State):
    id: UUID
    name: str

@runtime_checkable
class UserFetching(Protocol):
    async def __call__(self, user_id: UUID) -> User: ...

class UserService(State):
    fetch: UserFetching

    @statemethod
    async def get(self, user_id: UUID) -> User:
        return await self.fetch(user_id)

async def handler(user_id: UUID) -> User:
    async with ctx.scope("request", UserService(fetch=my_impl)):
        return await UserService.get(user_id)
```

## State Essentials
- Declare **all attributes with types**. Use `Sequence`/`Mapping`/`Set` (from `collections.abc`), not concrete `list`/`dict`/`set`. Use `| None` instead of `Optional`.
- Immutability is enforced; sequence/set fields are converted to immutable forms (`tuple`, `frozenset`), while mappings remain dict-like and should be treated as read-only. Mutations raise.
- Metadata via `typing.Annotated` with `Alias`, `Description`, `Specification`, `Meta`, `Validator`. Example:
```python
from typing import Annotated
from haiway import Alias, Description, Meta, Specification, State, Validator

class Invoice(State):
    total_cents: Annotated[int, Specification({"minimum": 0}), Validator(lambda v: v if v >= 0 else (_ for _ in ()).throw(ValueError(">=0")))]
    customer: Annotated[str, Alias("customer_id"), Description("External ID")]
    meta: Meta = Meta.of(kind="invoice")
```
- Lazy/default values: wrap in `Default(...)` or `Default(default_factory=...)`; env helpers integrate (`Default(env="API_KEY")`).
- Conversions: `to_mapping(recursive=True)` returns nested mapping/list structures honoring aliases and metadata.
- Generics: `class Box[T](State): value: T`; specialization is validated (`Box[int](value=1)` ok, `Box[int](value="x")` raises).

## Context & Scopes
- Enter scopes with a name string or a `ContextPresets` instance. Provide state instances and/or `disposables` (async context managers yielding state). Example:
```python
async with ctx.scope(
    ContextPresets.of("dev", AppConfig(...)),
    RuntimeConfig(debug=True),
    disposables=(HTTPXClient(base_url="https://api"),),
):
    config = ctx.state(RuntimeConfig)
```
- State lookup: `ctx.state(Type, default=...)`; `ctx.contains_state(Type)` -> bool. Missing raises `ContextStateMissing` if no default or default construction is possible.
- Presets compose reusable bundles of state + disposables; explicit parameters override preset contents. Use `ctx.presets(...)` to register multiple presets for name-based lookup.
- Events: `ctx.send(EventState)` publishes to subscribers; `async for e in ctx.subscribe(EventType): ...` consumes. Events are available only in isolated scopes (root scope or `isolated=True`); unsubscribed events are dropped.

## Concurrency Toolkit
- `ctx.spawn(callable, *args, **kwargs)` spawns in the current scope task group with context propagation; outside a scope it uses the background task group. Use `ctx.spawn_background(...)` to force background tasks. Cancel via `task.cancel()` or cooperative `ctx.check_cancellation()`. Unhandled child task failures are surfaced when the isolated scope exits.
- Streaming: `async for item in ctx.stream(async_generator_fn, *args): ...` preserves context for generator work.
- Concurrent helpers (all async-aware, preserve context):
  - `process_concurrently(source, handler, concurrent_tasks=2, ignore_exceptions=False)` – fire-and-forget per item, no result collection.
  - `execute_concurrently(handler, elements, concurrent_tasks=2, return_exceptions=False)` – gather ordered results.
  - `concurrently(*coros)` – lightweight gather wrapper; `stream_concurrently` for generator pipelines.
  - Rate control: `throttle(limit, interval)`, `timeout(seconds)`, `retry(...)` decorators; `asynchronous` converts sync callables to threads when absolutely needed.

## Resource Management
- Disposables are async context managers yielding `State` instances. They are started when entering the scope and always cleaned up. Use `ctx.disposables(disposable1(), disposable2())` as a helper inside an existing scope.
- Common disposables: `haiway.httpx.HTTPXClient` (HTTP backend), custom DB connections, etc.

## Functionalities & Services
- Expose contracts as `Protocol` objects (runtime-checkable only when you need `isinstance`). Name with gerund (`UserFetching`). Every method fully typed; async where I/O occurs.
- Services are `State` containers bundling protocol implementations. Public methods are `@statemethod` so you call `Service.method(...)` with context lookup, while keeping the instance available inside for multi-method orchestration.
- Implementations are plain functions operating on context state (`ctx.state(ConfigType)`); keep them pure where possible and translate external errors into typed exceptions.

## I/O Helpers
- **HTTP**: Use `haiway.helpers.HTTPClient` static methods (`get/post/put/delete/request`). Provide an implementation via state, typically `haiway.httpx.HTTPXClient` disposable. Responses are `HTTPResponse` (immutable; `await response.body()` returns bytes). Errors raise `HTTPClientError` (original cause in `__cause__`).
- **File access**: `haiway.helpers.File` is a typed async file helper backed by context-managed resources; respect `FileAccess` flags when opening.
- **Postgres**: the `haiway.postgres` package offers async client/state helpers aligned with `asyncpg` patterns; configure via state and keep operations async-only.

## Caching & Resilience
- Memoization: `cache` (LRU, in-process, async-only) and `cache_externally(make_key, read, write, clear?)` for custom backends. `clear_cache()` available when supported.
- Retries/timeouts/throttling: decorators from `haiway.helpers` integrate with `ctx.spawn` and preserve typing.

## Observability
- Logging: `ctx.log_debug/info/warning/error/critical(message_or_event, **fields)`; structured fields are encouraged. Never log secrets.
- Metrics/events: `ctx.record_info(...)/record_warning/record_error` or generic `ctx.record(event=?, attributes=?, metric=?, value=?, kind=?, unit=?)` depending on level. `ctx.trace_id()` surfaces the current trace identifier.
- To mirror logs to OTLP or similar, wire `LoggerObservability` or dedicated exporters under `haiway.opentelemetry` into the context.

## Configuration & Environment
- `Configuration`/`ConfigurationRepository` provide typed configs with repository-backed `load(required: bool = False, default: Configuration | None = None)` helpers. With `required=True`, loading falls back to contextual state and then class default instantiation (no-arg constructor) before raising `ConfigurationMissing`. `ConfigurationInvalid` signals validation/loading failures. `ConfigurationRepository.volatile(...)` is handy for tests.
- Env helpers: `getenv_*` (str/int/float/bool/base64) and `load_env` convert environment variables into typed values; prefer these instead of `os.getenv`.

## Non-Negotiable Rules for Contributions
- Full typing everywhere (params, returns, attributes). Avoid `Any`; if unavoidable, keep scope narrow.
- Use abstract collection types in public APIs; prefer `Mapping/Sequence/Set` over concrete mutables.
- Stay async throughout; never block the event loop. Use `asynchronous` only for legacy sync bridges.
- Never mutate `State`; always create new instances.
- No `print`; use context logging/observability. Do not leak secrets in logs or errors.
- Translate external exceptions at the boundary into typed, contextual errors (include provider/operation identifiers, redact sensitive payloads).
- Keep public symbols exported via `src/haiway/__init__.py` when adding new APIs, and add docstrings for public classes/functions in NumPy style.
